'''
The routine take as argument a c
@input:  A capital letter X in the set {'A','D','E','F','H'}, an integer n and optionally an array v of dimension n+1.
         X and n must be chosen such that X_n denote a Coxeter group. The point in the projective space of dimension n 
         represented by array v cannot lies on a hyperplane of reflection of group X_n, otherwise the routine return an
         error message. If v is not passed as argument, it is automatically generated by the routine, in such a way that
         it respect the condition above.
@output: A tuple (m,k), where k is the number of hyperplanes of reflection of group X_n, and k is the cardinality of the
         orbit of v under the action of groupe X_n.
'''

from numpy import dot, sqrt, array_equal, random, zeros, array
from generators import generators_A, generators_D, generators_E, generators_F, generators_H
import time

def orbit(X,n,v=None):
    start_time= time.time()
    if X == 'A': G = generators_A(n)
    elif X == 'D': G = generators_D(n)
    elif X =='E': G = generators_E(n)
    elif X == 'F' : G = generators_F(n)
    elif X == 'H' : G = generators_H(n)
    
    R = all_reflections(G,G)
    if v == None: v = random_vector(n,R) 
    else:
        #assert type(v) in (array), "The vector v passed as argument should be an array" # doesn't work!
        assert len(v) == n+1,"The dimension of v must be consistent with the dimension n (recall we are in homogeneous coordinates)."
        assert not is_on_hyperplane(v,R), "The vector v passed as argument lies on a hyperplane" 
    orbit_v = []
    orbit_v.append(v)
    orbit_v = all_reflections(orbit_v,G)
    
    # Matrix representation of the hyperplanes and the orbit                    
    matrix_R = zeros((len(R),n+1))
    matrix_orbit = zeros((len(orbit_v),n+1))
    for i in xrange(len(R)): matrix_R[i,:] = R[i]
    for i in xrange(len(orbit_v)): matrix_orbit[i,:] = orbit_v[i]
    print('The %s hyperplanes of reflections of this Coxeter group are (notice that the rotations are not computed by this program) : \n %s' %(len(R),matrix_R))
    print('\nThe orbit of the vector %s is : \n %s' % (v,matrix_orbit))
    print('Required time (in seconds) : %s' % (time.time()-start_time))
    return (len(R), len(orbit_v))

def all_reflections(X,G):
    R = list(X)
    for r in R:
        for g in G:
            if not array_equal(r,g):
                v = reflection(r,g)
                if not contains(R,v): R.append(v)
    return R

def reflection(p,r):
    v = p - 2*r*dot(p,r)/dot(r,r)
    return v

def contains(S,v):
    v = simplification(v)
    for vector in S:
        vector = simplification(vector)
        if array_equal(vector,v) or array_equal(vector,-v): return True
    return False

def simplification(vector):
    if sqrt(dot(vector,vector)) != 0: return vector / sqrt(dot(vector,vector))
    return vector

def random_vector(n,R):
    while True:
        v = random.randint(2*n, size = n+1)
        v[0] = 0.
        if not is_on_hyperplane(v,R): break
    return v
        
def is_on_hyperplane(v, R):
    for r in R:
        if dot(v,r) == 0: 
            return True
    return False    